<!-- Removido o coment√°rio de filepath para compatibilidade com navegadores -->
<html>
  <head>
    <title>PEQUENA APLICA√á√ÉO DE BUSCA NA LINGUAGEM RUST</title>
    <meta charset="utf-8"/>
    <style>
      body {
        font-family: 'Segoe UI', Arial, sans-serif;
        margin: 0;
        background: #f9f9f9;
        color: #222;
      }
      .container {
        max-width: 900px;
        margin: 2rem auto;
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 2px 8px #0001;
        padding: 2rem;
      }
      h1, h2, h3 { color: #1a237e; }
      pre {
        background: #f5f5f5;
        border-radius: 6px;
        padding: 1em;
        overflow-x: auto;
      }
      code { font-family: 'Fira Mono', 'Consolas', monospace; }
      .badge {
        display: inline-block;
        background: #1976d2;
        color: #fff;
        border-radius: 5px;
        padding: 0.2em 0.7em;
        font-size: 0.95em;
        margin-right: 0.5em;
      }
      .section { margin-bottom: 2.5em; }
      .highlight {
        background: #e3f2fd;
        border-left: 4px solid #1976d2;
        padding: 0.7em 1em;
        margin: 1em 0;
        border-radius: 5px;
      }
      .emoji { font-size: 1.2em; }
      a { color: #1976d2; text-decoration: none; }
      a:hover { text-decoration: underline; }
      ul { margin-left: 1.5em; }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- T√≠tulo e Badges -->
      <h1>üîé Buscador CLI: Indexa√ß√£o e Busca Eficiente de Arquivos de Texto em Rust</h1>
      <div>
        <span class="badge">Rust ü¶Ä</span>
        <span class="badge">CLI</span>
        <span class="badge">Indexa√ß√£o Recursiva</span>
        <span class="badge">Testes Automatizados</span>
      </div>
     
      <!-- Introdu√ß√£o -->
      <div class="section">
        <h2>1. Introdu√ß√£o</h2>
        <div class="highlight">
          <p>
            <b>Buscador CLI</b> √© uma aplica√ß√£o de linha de comando desenvolvida em Rust ü¶Ä para indexa√ß√£o r√°pida e busca eficiente de arquivos de texto (<code>.txt</code>, <code>.md</code>) em diret√≥rios locais. Permite buscas por palavras ou frases, com op√ß√£o de busca sens√≠vel a mai√∫sculas/min√∫sculas, exibindo o resultado de forma clara e detalhada.
          </p>
          <ul>
            <li>‚úÖ Indexa√ß√£o autom√°tica de arquivos de texto (busca recursiva)</li>
            <li>‚úÖ Busca r√°pida por palavras ou frases completas</li>
            <li>‚úÖ Exibe nome do arquivo, n√∫mero da linha e conte√∫do</li>
            <li>‚úÖ Suporte opcional a <b>Case Sensitive</b></li>
            <li>‚úÖ Interface amig√°vel no terminal</li>
            <li>‚úÖ Inclui testes automatizados unit√°rios, de integra√ß√£o e performance</li>
          </ul>
          <p><b>N√≠vel t√©cnico:</b> Intermedi√°rio em Rust.</p>
        </div>
      </div>

      <!-- Justificativa Did√°tica -->
      <div class="section">
        <h2>2. Justificativa Did√°tica</h2>
        <p>
          Desenvolver uma aplica√ß√£o de busca de arquivos em Rust √© um excelente exerc√≠cio para quem est√° aprendendo a linguagem, pois envolve conceitos fundamentais como manipula√ß√£o de arquivos, recurs√£o, tratamento de erros, uso de crates externos e testes automatizados.
        </p>
        <ul>
          <li><b>Por que √© necess√°rio?</b> Permite praticar leitura e escrita de arquivos, navega√ß√£o em diret√≥rios, uso de structs e enums, al√©m de integra√ß√£o com bibliotecas da comunidade (como <code>clap</code>).</li>
          <li><b>Vantagens gerais:</b>
            <ul>
              <li>Organiza√ß√£o modular do c√≥digo</li>
              <li>Facilidade de manuten√ß√£o e extens√£o</li>
              <li>Testabilidade e robustez</li>
            </ul>
          </li>
          <li><b>Ganho t√©cnico:</b>
            <ul>
              <li>Implementa√ß√£o recursiva e robusta para indexa√ß√£o de arquivos, com tratamento de erros idiom√°tico usando <code>Result</code> e <code>?</code>.</li>
            </ul>
          </li>
        </ul>
      </div>

      <!-- Arquitetura da Solu√ß√£o -->
      <div class="section">
        <h2>3. Arquitetura e Design da Solu√ß√£o</h2>
        <p>
          A aplica√ß√£o √© dividida em tr√™s m√≥dulos principais:
        </p>
        <ul>
          <li><b>main.rs</b>: Ponto de entrada, orquestra a execu√ß√£o e intera√ß√£o com o usu√°rio.</li>
          <li><b>config.rs</b>: Respons√°vel pelo parsing dos argumentos de linha de comando usando <code>clap</code>.</li>
          <li><b>indexer.rs</b>: Faz a leitura, indexa√ß√£o e filtragem dos arquivos de texto.</li>
        </ul>
        <p><b>Aplica√ß√£o dos princ√≠pios SOLID:</b>
          <ul>
            <li><b>Single Responsibility:</b> Cada m√≥dulo tem uma responsabilidade clara (configura√ß√£o, indexa√ß√£o, execu√ß√£o principal).</li>
            <li><b>Open/Closed:</b> F√°cil de estender para novos tipos de arquivos ou filtros sem alterar o n√∫cleo.</li>
            <li><b>Dependency Inversion:</b> Uso de crates externos desacoplados (<code>clap</code>, <code>tempfile</code> para testes).</li>
          </ul>
        </p>
        <p>
          O projeto suporta diferentes formas de utiliza√ß√£o: busca em arquivos, diret√≥rios e subdiret√≥rios, com filtros flex√≠veis.
        </p>
      </div>

      <!-- Implementa√ß√£o Detalhada: indexer.rs -->
      <div class="section">
        <h2>4. Implementa√ß√£o Detalhada</h2>
        <h3>4.1 M√≥dulo <code>indexer</code></h3>
        <ul>
          <li><b>Estrutura principal:</b> Define a struct <code>FileLine</code> para armazenar metadados de cada linha lida.</li>
          <li><b>Importa√ß√µes:</b> <code>std::fs</code>, <code>std::io</code>, <code>std::path</code> para manipula√ß√£o de arquivos e diret√≥rios.</li>
          <li><b>Depend√™ncias:</b> <code>tempfile</code> para testes automatizados.</li>
          <li><b>Fun√ß√£o principal:</b> <code>read_text_files</code> faz a leitura recursiva dos arquivos, filtrando apenas <code>.txt</code> e <code>.md</code>, e retorna um vetor de <code>FileLine</code>.</li>
        </ul>
        <div class="highlight">
          <b>Melhorias e Estrat√©gias:</b>
          <ul>
            <li><b>Filtro Correto de Extens√µes:</b> Apenas arquivos <code>.txt</code> e <code>.md</code> s√£o processados.</li>
            <li><b>Contagem Precisa de Linhas:</b> Todas as linhas, inclusive vazias, s√£o lidas corretamente.</li>
            <li><b>Tratamento de Erros:</b> Uso do operador <code>?</code> para propaga√ß√£o imediata de erros e verifica√ß√£o da exist√™ncia do diret√≥rio.</li>
            <li><b>Recurs√£o Confi√°vel:</b> Subdiret√≥rios s√£o processados de forma recursiva e segura.</li>
          </ul>
        </div>
        <h4>Exemplo de c√≥digo (<code>src/indexer.rs</code>):</h4>
        <pre><code>use std::fs;
use std::io::{self, BufRead};
use std::path::{Path, PathBuf};

#[derive(Debug)]
pub struct FileLine {
    pub file: PathBuf,
    pub line_number: usize,
    pub content: String,
}

pub fn read_text_files(dir: &Path) -> io::Result&lt;Vec&lt;FileLine&gt;&gt; {
    if !dir.exists() {
        return Err(io::Error::new(io::ErrorKind::NotFound, "Diret√≥rio n√£o encontrado"));
    }
    let mut results = Vec::new();
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                let sub_results = read_text_files(&path)?;
                results.extend(sub_results);
            } else if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                let ext = ext.to_lowercase();
                if ext == "txt" || ext == "md" {
                    let file = fs::File::open(&path)?;
                    let reader = io::BufReader::new(file);
                    for (i, line) in reader.lines().enumerate() {
                        let line = line?;
                        results.push(FileLine {
                            file: path.clone(),
                            line_number: i + 1,
                            content: line,
                        });
                    }
                } else {
                    println!("‚û°Ô∏è Ignorando arquivo n√£o suportado: {}", path.display());
                }
            }
        }
    }
    Ok(results)
}
</code></pre>
      </div>

      <!-- Implementa√ß√£o Detalhada: config.rs -->
      <div class="section">
        <h3>4.2 M√≥dulo <code>config</code></h3>
        <ul>
          <li><b>Uso da biblioteca <code>clap</code>:</b> Facilita o parsing de argumentos de linha de comando, tornando a interface mais amig√°vel e robusta.</li>
          <li><b>Resumo:</b>
            <ul>
              <li>Define a configura√ß√£o do programa (<code>Config</code>).</li>
              <li>Permite ao usu√°rio especificar diret√≥rio, termo de busca e sensibilidade a mai√∫sculas/min√∫sculas.</li>
              <li>Valores padr√£o tornam o programa f√°cil de usar mesmo sem argumentos.</li>
            </ul>
          </li>
          <li><b>Ponto de aten√ß√£o:</b> Sensibilidade a mai√∫sculas/min√∫sculas pode ser crucial dependendo do contexto.</li>
        </ul>
        <h4>Exemplo de c√≥digo (<code>src/config.rs</code>):</h4>
        <pre><code>use clap::Parser;

/// Configura√ß√£o da linha de comando
#[derive(Parser, Debug)]
#[command(name = "buscador")]
#[command(about = "Motor de busca simples para arquivos de texto", long_about = None)]
pub struct Config {
    /// Diret√≥rio a ser indexado
    #[arg(short, long, default_value = ".")]
    pub dir: String,

    /// Palavra ou termo a buscar
    #[arg(short, long, default_value = "")]
    pub query: String,

    /// Sens√≠vel a mai√∫sculas/min√∫sculas?
    #[arg(long, default_value_t = false)]
    pub case_sensitive: bool,
}
</code></pre>
      </div>

      <!-- Implementa√ß√£o Detalhada: main.rs -->
      <div class="section">
        <h3>4.3 Arquivo <code>main.rs</code></h3>
        <ul>
          <li><b>Importa√ß√µes:</b> <code>clap</code>, m√≥dulos internos (<code>config</code>, <code>indexer</code>), <code>std::io</code> e <code>std::path</code>.</li>
          <li><b>Resumo de funcionamento:</b>
            <ol>
              <li>Exibe mensagem de boas-vindas.</li>
              <li>Analisa argumentos da linha de comando.</li>
              <li>Solicita termo de busca se n√£o informado.</li>
              <li>Exibe informa√ß√µes do diret√≥rio e busca.</li>
              <li>Filtra linhas com base no termo de busca.</li>
              <li>Exibe resultados ou mensagem de erro.</li>
            </ol>
          </li>
        </ul>
        <h4>Exemplo de c√≥digo (<code>src/main.rs</code>):</h4>
        <pre><code>mod config;
mod indexer;
use clap::Parser;
use config::Config;
use indexer::read_text_files;
use std::path::Path;
use std::io::{self, Write};

fn main() {
    println!("üëã Bem-vindo ao Buscador CLI! üöÄ");
    let mut args = Config::parse();

    if args.query.is_empty() {
        print!("Por favor, digite o termo de busca: ");
        io::stdout().flush().unwrap();
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        args.query = input.trim().to_string();
        if args.query.is_empty() {
            eprintln!("‚ö†Ô∏è  Nenhum termo de busca informado. Encerrando o programa.");
            std::process::exit(1);
        }
    }

    println!("üìÅ Diret√≥rio: {}", args.dir);
    println!("üîç Termo: {}", args.query);
    println!("üî† Case sensitive: {}", args.case_sensitive);

    let path = Path::new(&args.dir);
    match read_text_files(path) {
        Ok(lines) => {
            println!("üìÑ {} linhas lidas para indexa√ß√£o", lines.len());
            let termo = &args.query;
            let case_sensitive = args.case_sensitive;
            let resultados: Vec<_> = lines
                .into_iter()
                .filter(|line| {
                    if case_sensitive {
                        line.content.contains(termo)
                    } else {
                        line.content.to_lowercase().contains(&termo.to_lowercase())
                    }
                })
                .collect();
            if resultados.is_empty() {
                println!("üîé Nenhum resultado encontrado para \"{}\".", termo);
            } else {
                println!("‚úÖ {} resultados encontrados:", resultados.len());
                for line in resultados.iter().take(15) {
                    println!(
                        "{}:{} -> {}",
                        line.file.display(),
                        line.line_number,
                        line.content
                    );
                }
            }
        }
        Err(e) => {
            eprintln!("‚ùå Erro ao ler arquivos: {}", e);
        }
    }
}
</code></pre>
      </div>

      <!-- Testes -->
      <div class="section">
        <h2>5. Testes Automatizados</h2>
        <p>
          O projeto inclui testes unit√°rios, de integra√ß√£o e de performance, garantindo robustez e confiabilidade. Para detalhes e demonstra√ß√µes, acesse:
          <ul>
            <li>Canal Youtube: <a href="https://www.youtube.com/@veteranoedev" target="_blank">Veterano e Dev</a></li>
            <li>V√≠deo espec√≠fico: <a href="https://youtu.be/1giv8YchRR4?si=Cgdcy8MSPLfyWoDz" target="_blank">Testes no Buscador CLI</a></li>
          </ul>
        </p>
      </div>

      <!-- Benchmark -->
      <div class="section">
        <h2>6. Benchmark: Rust vs Java</h2>
        <ul>
          <li><b>Performance:</b> Rust compila para c√≥digo nativo, oferecendo desempenho superior e uso eficiente de mem√≥ria em compara√ß√£o com Java, que depende da JVM.</li>
          <li><b>Seguran√ßa:</b> O sistema de tipos e o borrow checker de Rust previnem erros comuns de concorr√™ncia e acesso √† mem√≥ria, reduzindo bugs em aplica√ß√µes de busca intensiva.</li>
        </ul>
      </div>

      <!-- Considera√ß√µes Finais -->
      <div class="section">
        <h2>7. Considera√ß√µes Finais</h2>
        <ul>
          <li><b>Li√ß√µes aprendidas:</b> Modulariza√ß√£o, uso de crates externos, testes automatizados e boas pr√°ticas de tratamento de erros s√£o essenciais para aplica√ß√µes robustas em Rust.</li>
          <li><b>Limita√ß√µes:</b> A busca recursiva pode ser custosa em diret√≥rios muito grandes. N√£o h√° suporte a buscas paralelas ou indexa√ß√£o incremental.</li>
          <li><b>Melhorias poss√≠veis:</b>
            <ul>
              <li>Adicionar busca paralela para maior performance.</li>
              <li>Implementar cache de indexa√ß√£o para grandes volumes de dados.</li>
            </ul>
          </li>
        </ul>
      </div>

      <!-- Refer√™ncias -->
      <div class="section">
        <h2>8. Refer√™ncias</h2>
        <ul>
          <li>Autor: Sandro Reis (com apoio de prompts de IA)</li>
          <li>Reposit√≥rio: <a href="https://github.com/consultorsandro/buscador-cli.git" target="_blank">github.com/consultorsandro/buscador-cli.git</a></li>
          <li>Documenta√ß√£o Rust: <a href="https://doc.rust-lang.org/book/" target="_blank">doc.rust-lang.org/book/</a></li>
          <li>Canal Youtube: <a href="https://www.youtube.com/@veteranoedev" target="_blank">Veterano e Dev</a></li>
        </ul>
      </div>
    </div>
  </body>
</html>